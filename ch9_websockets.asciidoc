== Replacing HTTP with WebSockets

This chapter starts with introducing of existing legacy options for creating interactive Web applications. After that we're going to introduce Server-Sent Events (SSE) and WebSockets, which are included in the HTML5 specification.

We're going to implement monitoring of the fund-raising events and an interactive auction for our Save Sick Child application using WebSockets and  Server-Sent Events. We'll use Wireshark, a network monitoring tool, and Google Chrome Developer Tools to see benefits of using WebSockets protocol.

All server-side functionality supporting this chapter is written in Java, using Java API for WebSocket http://java.net/projects/tyrus[reference implementation], which will be the part of upcoming Java EE 7 specification running on http://dlc.sun.com.edgesuite.net/glassfish/4.0/promoted/[latest promoted builds Glassfish Application Server]. If you don't know Java, just treat this server side setup as a service that supports WebSockets. For Java developers interested in diving into the server-side, we'll provide the source code and brief comments as a part of the code samples that come with this book.

We're going to show and compare the server-side data push with Server-Sent Events and WebSockets. Also we will do a brief overview of popular existing frameworks that can streamline you WebSockets application development.

=== Near Real Time Applications With HTTP

The HTTP protocol is the lingua franca of today's Web  applications, where client-server communications are based on the request-response paradigm. On the low level, Web browsers establish a TCP/IP connection for each HTTP request-response session.  Every time when the browser needs to send data to server and get response back the browser re-establish the TCP/IP connection. So to implement interactiveness in your application currently, there are 3 basic options that developer has to use today to satisfy the real-time client-server communication requirements. Basically, that options provide hacks on top of half-duplex HTTP protocol to simulate real-time behavior. Lets discuss each of them.

==== Polling ====

With _polling_, your client code sends requests to the server every N seconds. The response will have no data load if there were no updates on the server side as illustrated in <<FIG9-1>>. Visualize a child seating on back seat of your car and asking, "have we arrived yet?" every minute. And you're politely replying "Not just yet" - compare it to an empty server response. There is no valuable payload for this kid, but she's still receiving some "metadata". HTTP polling does the same thing that generates verbose HTTP response headers sending empty payload. Let alone destructing the driver (think the server) from performing other responsibilities.

[[FIG9-1]]
.Polling
image:images/fig_09_01.png[image]

==== Long Polling ====

_Long polling_ (illustrated in <<FIG9-2>>) starts similarly to polling: the client sends HTTP request to server. But in this case instead of sending an empty response (as in case with polling), server waits till the data for the client becomes available. If the requested information is not available after the specified timeout, the server server sends an empty response to the client and closes the connection.

We'll give you one more analogy to compare polling and long polling. Imagine a party at the top floor of a building equipped with a smart elevator that goes up every minute and opens the door just in case if one of the guests wants to go down to smoke a cigarette. If no one enters the elevator, it goes to the ground level and in 60 seconds goes up again. This is the polling scenario. But if this elevator would go up, and waited till someone would actually decided to go down, then we could call it a long polling mode.

From HTTP specification perspective this hack is legit: the long polling server behavior is indistinguishable from the slow server.  That is why this technique also referred as _Hanging GET_. If you see an online auction that automatically modifies the prices as people bid on the item it looks as if the server pushes the data to you. But most likely, this functionality was implemented using long polling, which is not a real server-side data push, but its emulation.

[[FIG9-2]]
.Long Polling
image:images/fig_09_02.png[image]

TODO Compare pros and cons of long vs short polling

==== HTTP Streaming ====

Client sends the request, server wait for events and  streams +multipart/chunked+ response, and then waits for the events. The server pushes the data to the client pretending that the response never ends <<FIG9-3>>. The response is continually appended by the server, usually with `<script>` what gets executed even after the HTTP DOM object is ready

[[FIG9-3]]
.HTTP Streaming
image:images/fig_09_03.png[image]

Polling and streaming can be used as a fall-back for legacy browsers that don't support the modern HTML5 APIs _Server-Sent Events_ and _WebSockets_.

=== Server-Sent Events ===

Before diving into WebSockets protocol lets get familiar with the standardized way of implementing  http://dev.w3.org/html5/eventsource/[Server-Sent Events]. W3C introduces API for the Web browsers and the +EventSource+ object. SSE allows to subscribe to remote server events arriving in the form of DOM events. The following code snippet shows the JavaScript code that can be used in a Web browser.

[source,javascript]
-----------------------------------------------------
include::include/sse_api_example.js[]
-----------------------------------------------------

<1> Create new +EventSource+ object. At this point the browser will sends the +GET+ request to the specified server-side endpoint to register itself on the server
<2> Add handlers for the +open+ and +error+ events
<3> Handle messages in +create+ events
<4> Handle messages in +update+ events

Using SSE is a good technique for the use cases when the client doesn't need to send the data to the server. In the above example the server sends two types of events +create+ and +update+ to notify subscribed clients about changing information about donation data so connected clients can monitor fund-raising process. We can create as many named-events as we want.
This technique is still HTTP-based, and it requires the server's support of a combination of HTTP 1.1 keep-alive connections and the `text/event-stream` content type. The overhead is minimal - instead of hundreds of bytes, the server sends only tens of bytes.

=== Introducing WebSockets

[quote, HTML spec editor at Google, Ian Hickson]
____

Reducing kilobytes of data to 2 bytes is more than "a little more byte efficient", and reducing latency from 150ms (TCP round trip to set up the connection plus a packet for the message) to 50ms (just the packet for the message) is far more than marginal. In fact, these two factors alone are
enough to make WebSocket seriously interesting to Google.

source: http://ietf.org/mail-archive/web/hybi/current/msg00784.html
____

WebSockets is a bi-directional full-duplex socket-based protocol. According to http://tools.ietf.org/html/rfc6455[RFC 6455]  - the Internet Engineering Task Force (IETF) standard document - the goal of WebSocket technology is to provide mechanism for web applications what need two-way communications with servers. This technology shouldn't rely on HTTP hacks or on opening multiple connections using +XMLHttpRequest+ or `<iframe>` and long polling. The idea behind WebSockets is straightforward:

- Establish a socket connection between the client and the server using HTTP for the initial handshake.
- Switch the communication protocol from HTTP to direct socket-based protocol.
- Send messages in both directions simultaneously (a.k.a. full duplex mode).
- Send messages independently. This is not a request-response model. Both the server and the client can initiate data transmission which enables the real server-side push.
- Both the server and the client can initiate  disconnect.

<vik>
Also WebSocket protocol defines two new URI schemes `ws` and `wss` for unencrypted and encrypted connections respectively. The `ws` URI schema identifies that a WebSocket connection will be established using TCP/IP protocol without encryption. The`wss` URI schema identifies that traffic over that connection be protected via Transport Layer Security (TLS) including standard benefits of TLS such as data confidentiality and integrity and endpoint authentication.
<vik>Apart from the scheme name, the rest of the URI components are defined to use URI generic syntax.</vik>
<vik>We will see how each of these statements reflects in WebSocket API section later in this chapter.</vik>

==== WebSockets Interface ====

To define an abstract Web socket interface the expert group uses http://en.wikipedia.org/wiki/Interface_description_language[Interface Description Language].

[source,java]
----------------------------------------------------------------------
include::include/ws_interface.il[]
----------------------------------------------------------------------

<1> The constructor requires an endpoint URI and optional sub-protocols name.
<vik>Essentially, the WebSocket protocol introduces only new type of transport and doesn't define new application layer protocol. In this case, it's possible to transfer existing standard protocols messages (such as SOAP, XMMP and etc) on top of WebSocket. With filling this array with protocol names, we tell the server that our client can use standard protocols.</vik>

<2> At any given time the WebSocket can be in one of four states.

<3> These are the callback functions of WebSocket object that will be invoked by the browser once the appropriate network event is fired.

<4> WebSocket object can send text or binary data to server using on of the `send()` methods.

===== The Client-Side API =====

After introducing the WebSockets interface lets see the code example illustrating how the client's JavaScript can use it.

[source,javascript]
----------------------------------------------------------------------
include::include/ws_api_example.js[]
----------------------------------------------------------------------

<1> Not all Web browsers support WebSockets natively as of yet. Check if the +WebSocket+ object is supported by the user's browser.

<2> Instantiate the new +WebSocket+ object with passing an endpoint URI as constructor parameter.

<3> Set the event handlers for `open`, `message`, `close` events.

<4> The `MessageEvent` is <vik> fired </vik> when the data is received from the server. <vik>This message will be delivered to the function assigned to the WebSocket object's `onmessage` property. </vik> The `e.data` property of the message event contains the received message.

<5> Handle closing connection (more details in <<CLOSSING>> section).

<6> Handle errors

[[HANDSHAKE]]
===== WebSockets Handshake

Any network communications that uses WebSockets protocol starts with an opening handshake. The handshake upgrades the connection from HTTP to the WebSockets protocol. It's an upgrade to a message-based communications. We will discuss messages (a.k.a. frames) later in this chapter. Why upgrading from HTTP instead of starting with the TCP as a protocol in the first place? The reason is that the WebSockets operates on the same ports (80 and 443) as HTTP and HTTPS do. It's an important advantage that the browser's requests are routed through the same ports because arbitrary socket connections are not allowed by the enterprise firewalls for security or scalability reasons. Also, many corporate networks only allow certain ports outgoing. And HTTP/HTTPS ports are usually included in so called _white lists_.

The protocol upgrade is initiated by the client request, which also transmits a special key with the upgrade request. The server processes this request and send back a confirmation for the upgrade. This ensures that a WebSocket connection cannot be established with an endpoint that is not aware of the WebSockets protocol. Here is what the handshake looks can like in the client's request:

----------------------------------------------------------------------

    GET HTTP/1.1
    Upgrade: websocket
    Connection: Upgrade
    Host: echo.websocket.org
    Origin: http://www.websocket.org
    Sec-WebSocket-Key: i9ri+AfOgSsKwUlmLjIkGA==
    Sec-WebSocket-Version: 13

----------------------------------------------------------------------

This client sends the +GET+ request for the protocol upgrade. The +Sec-WebSocket_Key+ is just a set of random bytes. The server takes these bytes and appends to it a special Global Unique Identifier (GUID) string `258EAFA5-E914-47DA-95CA-C5AB0DC85B11`, then creates theSecure Hash Algorithm +SHA1+ hash from it followed by the _base64_ encoding. The resulting string of bytes needs to be used by both the server and the client, and it's unlikely that this string will be used by the network endpoints that do not understand the WebSockets protocol. Then this value would be copieded in the `Sec-WebSocket-Accept` header field. When the server has computed the value it can send the response back confirming the protocol upgrade.

----------------------------------------------------------------------

    HTTP/1.1 101 Web Socket Protocol Handshake
    Upgrade: WebSocket
    Connection: Upgrade
    Sec-WebSocket-Accept: Qz9Mp4/YtIjPccdpbvFEm17G8bs=
    Access-Control-Allow-Origin: http://www.websocket.org

----------------------------------------------------------------------

The WebSockets protocol uses the `400 Bad Request` error to signal the missing upgrade. The handshake can also include a protocol request and the WebSocket version information but you can't include arbitrary other headers. We can't transmit the authorization information. There are two ways around this. You can either transmit the authorization information as the first request (e.g. unique `clientId` can be passed as part of the HTTP response header or HTML wrapper) or put it into the URL as a query parameter during the initial handshake. Consider the following example.

[source,javascript]
----------------------------------------------------------------------
var clientId = AppContext.getClientId();                        // <1>
ws = new WebSocket("ws://www.websocket.org/echo/"+clientID); // <2>

----------------------------------------------------------------------

<1> Here we're getting clientId value from the  `AppContext` singleton object.
<2> We're connecting to the WebSockets endpoint with an extra URI parameter which will be stored on server for future interactions.

Because WebSockets protocol creates a bi-directional (socket-to-socket) connection server has access to conversation session associated with the new web socket connection. This session can be associated with clientId and be stored on server.

****

NOTE: There is no limit to the number of established WebSocket connections a client can have with a single remote host.  Servers can refuse to accept connections from hosts/IP addresses with an excessive number of existing connections or disconnect resource-hogging connections in case of high data load.

****

[[FRAMES]]
===== The WebSocket Frame Anatomy =====

The WebSocket handshake is followed by the message framing layered over TCP. In this section we're going to explore how the WebSocket data transfer works. The WebSocket is not a stream based protocol like TCP - it's message based. The difference is that with TCP a program sends the bytes and has to ensure that the end of a message can be recognized.
The WebSocket specification makes it easier because it puts a frame around everything. It's easy to do  from the JavaScript on the client, but it's harder to handle in the server side code because it needs to wrap everything in frames. The frame can look like this:

----------------------------------------------------------------------

+-+-+-+-+-------+-+-------------+-------------------------------+
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+

----------------------------------------------------------------------

- `FIN` (1 bit)

This bit indicates if this frame is the final frame that makes up the message. Most of the time the message fits into a single frame and this bit will always be set.

- `RSV1`, `RSV2`, `RSV3` (1 bit each)

These bits are the reserved for future protocol changes and improvements. They must contain zeros as they are not being used at this time.

* `opcode` (4 bits)

+
.The frame type is defined using opcode. Here most used opcodes:

** `0x00` This frame continues the payload from the last.
** `0x01` This frame includes UTF-8 text data.
** `0x02` This frame includes binary data.
** `0x08` This frame terminates the connection
** `0x09` This frame is a Ping.
** `0x10` This frame is a Pong.

- `mask` (1 bit)

This indicates if the frame is masked.

****

NOTE: The client must mask all the frames being sent to the server. The server must close the connection upon receiving a frame that is not masked. The server must not mask any frames that it sends to the client.  The client must close a connection if it detects a masked frame. In that case of such error, client or server can send `Close` frame with 1002 status code - protocol error.

****

* `payload_len` (7 bits, 7+16 bits, or 7+64 bits)

The length of the payload. WebSocket frames come in the following length brackets:
   ** 0-125 indicate the length of the payload.
   ** 126 means that the following two bytes indicate the length.
   ** 127 means the next 8 bytes indicate the length.

* `masking-key` (32 bits)

This key is used to _XOR_ the payload with.

* `payload`

This indicates the actual masked data. The length of block is defined in the `payload_len` bits.

===== The Heartbeats =====

Certain things like transparent and explicit proxy servers or a content-filtering hardware can terminate the idle connections or a remote side could go down. Only on  the next send your program can realize that something went wrong. With WebSockets the browser can send the _ping_ opcode `0x9` at any time to ask the other side to _pong_ back (the opcode `0xA`).

Pings can be sent whenever required, but a pong may sent at server's discretion. If an endpoint receives a Ping frame and has not yet sent Pong frame(s) in response to the previous Ping frame(s), the endpoint can elect to send a Pong frame for only the most recently processed Ping frame. The Ping frame may contain the application data (can be up to 125 bytes) and Pong must have identical data in message body.

There is no JavaScript API to send Ping frames or receive Pongs http://www.whatwg.org/specs/web-apps/current-work/multipage/network.html#ping-and-pong-frames[frames]. This is either supported by your browser, or not. http://www.w3.org/Bugs/Public/show_bug.cgi?id=13104[There is also no API] to enable, configure or detect whether the browser supports and is using Ping/Pong frames.


===== Data Frames =====

As we explained earlier in this chapter, the WebSockets protocol allows the data to be fragmented into multiple frames. If this happens, the first frame that transmits the data will be prepended with one of the following opcodes indicating the type of data being transmitted:

- The opcode `0x01` indicates the UTF-8 encoded text data.
- The opcode `0x02` indicates the binary data.

When your application transmits JSON over the wire the text opcode is set for frames. When your code emits binary data it will be represented in a browser specific `Blob` object or an `ArrayBuffer` object and sent wrapped into a frame with the binary opcode.

NOTE: You must choose the type for the incoming binary data on the client using `webSocket.binaryType = "blob"` or `webSocket.binaryType = "arraybuffer"` before reading the data.

It's good idea to check the type of the incoming data because the opcodes are not exposed to the client.

[source, javascript]
----------------------------------------------------------------------
webSocket.onmessage = function(messageEvent) {
    if (typeof messageEvent.data === "string"){
        console.log("received text data from the server: " + messageEvent.data);
    } else if (messageEvent instance of Blob){
        console.log("Blob data received")
    }
};
----------------------------------------------------------------------

[[CLOSSING]]
===== Closing The Connection =====

The connection is terminated by sending the frame with the close opcode `0x08`.

There is the pattern to exchange close opcodes first and then let the server shut down. The client is supposed to give the server some time to close the connection before attempting to do that on its own. The close event can also signal why it terminated the connection.

A `CloseEvent` is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's `onclose` handler. `CloseEvent` has 3 properties - code, reason, wasClean.

.Legend
[width="100%",cols="",options=""]
|===
|code    | This property represents close code provided by the server
|reason   | A string indicating reason why server closed connection
|wasClean| The property indicates that was or wasn't cleanly closed
|===

[source,javascript]
----------------------------------------------------------------------
webSocket.onclose = function(closeEvent) {
    console.log("reason " + closeEvent.reason + "code " + closeEvent.code);
};
----------------------------------------------------------------------

=== Client-side WebSockets frameworks ===

==== The Portal ====

The Portal[https://github.com/flowersinthesand/portal] is a server agnostic JavaScript library that not just provides a socket for browser-based applications that need two-way communication with servers, but also aims to utilize a full duplex connection for modern web application development.

==== Atmosphere.js ====

Atmosphere.js[https://github.com/Atmosphere/atmosphere/wiki/jQuery.atmosphere.js-API]

=== WebSocket Use Cases

Since WebSocket protocol has literally no overhead it makes it worthwhile to consider for the following types of applications:

- Live trading/auctions/sports notifications
- Controlling medical equipment over the web
- Chat applications
- Multi-player online games
- Real-time updates in social streams

For the "Save Sick Child" application we're going to use WebSockets to implement an online auction communication layer. The goal is to let individuals and businesses purchase hand-made crafts and arts made by the children. All proceeds will go to help sick children.

==== Protocols Considerations for Enterprise Applications

The downside: WebSockets specification gives you only the transport, but it doesn't include the application-level protocol. Developers need to invent the application-specific text or binary protocols. For example, the auction bid has to be presented in a form agreed upon by all application modules. Let's discuss our options from protocol modeling perspective.

Selecting a message format for the your application's data communications is important. The most common text formats are CSV, XML and JSON. They are easy to generate, parse,  and are widely supported by many frameworks in most major development platforms. While XML and JSON allow you to represent the data in a hierarchical and easily readable by humans form, they create a lot of overhead by wrapping up each data element into additional text identifiers. Sending such additional textual information places consumes a lot of extra bandwidth and may need additional string-to-type conversion on both the client and server's code. The binary format is an alternative way of sending data.

===== CSV =====

CSV stands for Comma Separated Values although the delimiter can be any character, not only comma. It depends on parser design and implementation. Another popular type of delimiter is `|` - "pipe" . Lets describe pros and cons of the CSV message format.

Pros:

- This format is very compact. The overhead of the separator symbol is minimal.
- It's simple to create and parse. The CSV message can be turned into array of values by using the standard JavaScript `String.split()`

Cons:

- It's not suitable for storing complex data structures and hierarchies. In case of an auction application, we need transfer to client auction items' attributes for each auction. In this case we can't simple use general purpose `String.split()` and have to design and implement a more complex parser.

===== XML =====

XML stands for Extensible Markup Language, and it nicely represents any hierarchal data structures.

Pros:

- It's a human-readable format.
- Most browsers have build-in XML readers and parsers.
- XML data can be validated against XSD or DTD schema.
+
XML schema is very useful language feature as it defines structure, content and semantic of XML document. Because of its human-readability the XML schema can be used used by people who are not software developers and can be applied for integrating systems written in different programming languages.

Cons:

- XML is very verbose. To send a name of a customer you'd need something like this: `<cust_name>Mary</cust_name>`
- The XML validation on the client is a complex task. As for now, there is no platform independent solutions or the API to perform validation programmatically based on XSD or DTD.

The book  _XML in a Nutshell, 3rd Edition_ by Elliotte Rusty Harold and W. Scott Means is a well-written book describing the full spectrum of XML features and tools.


===== JSON =====

As explained in Chapter 4, JSON stands for JavaScript Object Notation, and it's a way of representing structured data, which can be encoded and decoded by all modern browsers. JSON is widely accepted by the Web community as a popular way of the data serialization.

===== Google Protocol Buffers =====

Google Protocol Buffers is a language and platform-neutral extensible mechanism for structured data serialization. Once defined how you want your data to be structured, you can use special generated source code to easily write and read your structured data to and from a variety of data streams.

A developer needs to specify how the serializable information has to be structured by defining the protocol buffer message types in the +.proto+ files. Each protocol buffer message is a small logical record of information, containing a series of the name/value pairs. This protocol buffer message file is language agnostic. The `protoc` utility compiles +proto+ files and produces language specific artifacts, e.g. +.java+, +.js+, etc files.

Pros:

_TBD_

Cons:

_TBD_


=== WebSockets and Proxies

The WebSocket protocol itself is unaware of intermediaries such as proxy servers, firewalls, content filters. The proxy servers are commonly used for content caching, security and enterprise content filtering.

HTTP always supported  protocol upgrades, but many proxies seem to have ignored that part of the specification. Until the WebSockets came around no one was actually using the Upgrade attribute.

_TBD_

If you want to get more details how WebSockets-enabled application works with proxies there is perfect research paper by Peter Lubbers http://www.infoq.com/articles/Web-Sockets-Proxy-Servers/[WebSocket and proxy servers].

=== WebSockets and HTTP 2.0

[quote, Chief Product Architect at Akamai, Stephen Ludin]
____
"I use the metaphor of hammers and screwdrivers. Both tools are indispensable in my workshop...
Use the right tool for the job.
In the case of page and object delivery use SPDY.
In the case of lightweight or streaming data delivery look to WebSocket."

source: https://blogs.akamai.com/2012/07/spdy-and-websocket-support-at-akamai.html
____

_TBD_

- http 2.0, spdy, websockets
- framed protocols (describe frames)

=== Adding an Auction to Save Sick Child

We gave you just enough of a theory to whet your appetite for implementing WebSockets in our Save Sick Child application. The goal is to create an auction where people can bid and purchase various goods so the proceeds would go to sick children. Auctions require real-time communications - everyone interested in the particular auction item must be immediately notified if another bidder increased the price. So we'll use WebSockets as a means for bidding and notifications of the changes in the auction.

To start the auction, the user of the Save Sick Child application has to select the _Auction_ option under the menu _Way To Give_. We realize that only a small number of the users will decide to participate in the auction, which from the architectural point of view means that the code supporting the auction should be loaded _on demand_ only if the user chooses to visit the auction. This why we need to write this code as a loadable module, and the reader will get a practical example of how a Web application can be modularized.

In this chapter we continue to use RequireJS explained in the previous chapter as a framework that helps manage our JavaScript application components in a modular fashion. Using RequireJS, we're going to lazy load some modules if and only if they ever get requested by the user.

This is dedicated to the development of the user interface and client side of the Web applications hence we're not going to cover all the details of server side implementation, but will make our server side code available for download. We'll keep our server up and running so you can test the UI, but our main goal in this section is to show you how you can exchange the auction data with the server and process them on the client side. We use the current version of WebSockets support offered by the Java application server GlassFish 4, which is a reference implementation of the latest Java EE 7 specification.

Authors of this book are Java developers and we have provided a sidebar with the details WebSockets server API which is a part of Java EE 7. If you are not a Java developer, you may want to learn on your own which WebSocket servers exist for your favorite programming language or platform. But strictly speaking, if you are a front-end developer, you don't have to know how the WebSocket server works under the hood.

****************************************************************************
include::include/ws_javaserver_sidebar.asciidoc[]
****************************************************************************

In Chapter 8 you had a chance to see how a Web application can be sliced (see Aptana's project-15-dynamic-modules) into several modules using Require.js framework.  We'll take this project as a base and will create a new one: project16-websocket-auction adding to it the new modules supporting the auction.

.Way To Give module (+js/modules/way-to-give.js+)
[source,javascript]
----------------------------------------------------------------------
define([], function () {
    var WayToGiveMod = function () {
        return {
            renderControls: function () { // <1>

            },
            startAuction: function () {   // <2>
            },
            rendered: false             // <3>
        }
    };
    return WayToGiveMod;
});
----------------------------------------------------------------------

<1> This function will lazy load the auction application content and render it to the top main section of the Web page.

<2> This function will start the auction.

<3> The module stores the rendering state in this property.


Once the application starts, the require.js loads only essential modules - login and donation <<FIG9-9>>.

[[FIG9-9]]
.Two modules are loaded during the Save Sick Child application startup
image::images/fig_09_09.png[]

In Google Chrome Developer Tools Console we can see that login and donation modules are reporting about successful loading. In <<FIG9-10>> we can see that these modules perform fine.

[[FIG9-10]]
.Two modules are loaded during the Save Sick Child application startup
image::images/fig_09_10.png[]

Now click WayToGive menu item and keep an eye on the Developer Tools Console <<FIG9-11>>. You will see how the WayToGive module reports about its loading and rendering.

[[FIG9-11]]
.The auction controls are loaded and rendered
image::images/fig_09_11.png[]

Once the user clicks the menu Way to Give the framework require.js has to load code of WebSocket-based auction module. Here is the code of `app.js` - the entry point of our Save Sick Child application. The following code snipped illustrates the mechanics how we loading the module _on demand_.

[source,javascript]
----------------------------------------------------------------------
include::include/loading_modules_on_demand.js[]
----------------------------------------------------------------------

<1> This function will lazy-loaded only if the user clicks on Way To Give menu.

<2> WayToGive module will has a value if `null` until loaded.

<3> If the user clicks while the `WayToGive` module is still being lazily loaded, simply ignore this click - when the module finally loads, it will open the module.

<4> If the module has been loaded and UI has been rendered start Auction application.

<5> Set an intermediary value to the WayToGive module so that subsequent requests don't try to launch the module more than once.

<6> Load module asynchronously and instantiate it.

<7> Render UI component to the screen for first time.

<8> Register the click event listener for the Way To Give menu.


After the UI elements have rendered we can connect to the WebSocket server and request list of all available auction items.

[source,javascript]
----------------------------------------------------------------------
include::include/auction_set_ws_listeners.js[]
----------------------------------------------------------------------

<1> After establishing connection we're requesting list of available auctions. We'll see details of `getAuctionsList()` method in next snipped.

[source,javascript]
----------------------------------------------------------------------
include::include/auction_ws_send_message.js[]
----------------------------------------------------------------------
<1> Forming the request message. Details of the message format could be found in <<Auction_Messages_Specification>> section.

<2> Checking the WebSocket object state. If WebSocket is open (`readyState===1`) the application can send a  message. If not, just simply log this on the console. In the real world situations if your users work on unstable networks such as cellular or 3G you definitely don't want to lose any bits of your data. It's a good idea to use local storage API to persist the data locally until application gets back online and resubmit the data.

The user can select a lot from combo box and see photos of it <<FIG9-12>> and <<FIG9-13>>

[[FIG9-12]]
.The console logs incoming message contains list of auction items.
image::images/fig_09_12.png[]

[[FIG9-13]]
.Using Network feature of Dev Tools we can monitor WebSocket frames.
image::images/fig_09_13.png[]

[[FIG9-14]]
image::images/fig_09_14.png[]

==== Monitor the WebSockets traffic with Chrome Developers Tools ====

Let's see whatever is described in the <<HANDSHAKE>> action.  With the help of Chrome Developer Tools you can monitor the information about the initial handshake <<FIG9-4>>. This can be viewed in the Network tab after selecting the path of the `WebSocket` endpoint.

[[FIG9-4]]
.Initial WebSockets handshake in Chrome DevTools
image::images/fig_09_04.png[]

You can also click on +WebSockets+ on the bottom-right to show only the `WebSocket` endpoints. Click on +Frames+ in the right panel to view the actual frames being exchanged between the client and server. <<FIG9-5>>. The white colored rows represent incoming data, and the green rows - outgoing.

[[FIG9-5]]
.Monitoring WebSocket frames in Chrome Developer Tools
image::images/fig_09_05.png[]

For more gore details you can navigate your Google Chrome to the secret URL - `chrome://net-internals`, which is a very useful URL showing a lot of additional information (see <<FIG9-6>> and <<FIG9-7>>).

[[FIG9-6]]
.Details of initial handshake in Chrome Net Internals
image::images/fig_09_06.png[]


[[FIG9-7]
.Details of the socket connection
image::images/fig_09_07.png[]

Google Developer Tools show just the length of payload data. But `chrome://net-internals` shows the actual size of the WebSocket frame too. <<FIG9-8>> compares the views of net-internals and Developer Tools. As we learned earlier in this chapter, the total size of frame is slightly different from size of the payload. There are few bytes for frame header. <vik>Moreover, all outgoing messages will be masked by browser WebSocket implementation (see NOTE in <<FRAMES>> section). This frame's mask should be transfered to the server and that creates additional 32 bits = 4 bytes overhead.</vik>

[[FIG9-8]]
.Dev tools and net-internals side by side
image::images/fig_09_08.png[]


==== Sniffing WebSockets frames with Wireshark ====


Wireshark is a powerful and comprehensive monitorin tool for analyzing the network traffic.


[[Auction_Messages_Specification]]
==== Auction Messages Specification

1. The client's code connects to the WebSockets endpoint on the server.
2. The client's code sends `AUCTION_LIST` message to retrieve the list of currently running auctions.
+

.Request for list of available auctions
[source,javascript]
----------------------------------------------------------------------
include::include/auctions_list_request.json[]
----------------------------------------------------------------------
<1> type of message is `AUCTION_LIST`
<2> empty data
<3> We don't know exact auction id so we just send `-1`

+
Let's review the JSON object that will be arriving from the server as the auction's response.
+

.Response with auction list data
[source,javascript]
----------------------------------------------------------------------
include::include/auctions_list_response.json[]
----------------------------------------------------------------------
<1> The message type is `AUCTION_LIST`
<2> The +data+ property of the response object contains the list of all running auctions. An auction can be in one of three states: _not running_, _running_, or _finished_.
<3> The +item+ property of the response object is a nested object that represents the auction item.
<4> The +auctionId+ property contains a unique identifier of the selected auction.

3. The user picks the auction from the list, enters a desired nick name, and joins to the auction. The client-side application sends the following +login+ message.
+

[source,javascript]
----------------------------------------------------------------------
{
    "type": "LOGIN", // <1>
    "data": "gamussa", // <2>
    "auctionId": "second" //<3>
}
----------------------------------------------------------------------

<1> The message type is `LOGIN`
<2> The +data+ property of the request contains the user's nickname.
<3> The +auctionId+ property helps the server-side code to route the message to the correct auction.

+

NOTE: As soon as the handshake completes successfully, the server side code that implements `WebSocket` protocol exposes the WebSocket session object.  The session object encapsulates conversation between the WebSocket endpoint (server - side) and remote endpoint (browser). Check the documentation for your server side framework for details about how it handles and exposes the remote endpoints in API.
+

4. Each time when the user enters the bid price client side code sends following +bid+ message:
+

.Bit message
[source,javascript]
----------------------------------------------------------------------
{
    "type": "BID",
    "data": "1100.0",
    "auctionId": "second"
}
----------------------------------------------------------------------
+

This is outgoing message. When user clicks on "Bid!" button text from bid text box wrapped to Bid message. On the server, bid message data value compared with best bid value and if it's
+

5. `PriceUpdate` message
+

.PriceUpdate message
[source,javascript]
----------------------------------------------------------------------
{
    "type": "PRICE_UPDATE", //<1>
    "data": "1300.0", //<2>
    "auctionId": "second"
}
----------------------------------------------------------------------

<1> If some auction participant outbids others, the rest of participants will receive update.
<2> Such an update will contain the current highest bid.
+

6. `AuctionResult` message
+

.AuctionResult message
[source,javascript]
----------------------------------------------------------------------
{
    "type": "RESULT",
    "data": "Congrats! You\u0027ve won Painting for $1300.0",
    "auctionId": "first"
}
----------------------------------------------------------------------
+

After the auction ends, the server broadcasts the message with auction results. If the wining user is online and connected to the auction server, the item message will contain congratulations.  Other participant will get the loose notifications.

=== Summary

This chapter was about the WebSocket protocol. By now you should see the benefits of using WebSocket protocol in applications. In many cases WebSockets is an ultimate means for improving the application performance by reducing the network latency and removing the HTTP-headers overhead. We learned how to integrate WebSocket-based functionality into the existing HTTP-based application Save Sick Child.

You've learned how to use the network monitoring capabilities of Google Chrome Developer Tools and Wireshark application by sniffing the WebSocket traffic. You can't underestimate the importance of monitoring tools, which are the best friends of Web developers.
