== Replacing HTTP with WebSockets

[quote, http://ietf.org/mail-archive/web/hybi/current/msg00784.html ]
____
Reducing kilobytes of data to 2 bytes… and reducing latency from 150ms
to 50 ms is far more than marginal. In fact, these two factors alone are
enough to make WebSocket seriously interesting…
____

This chapter will introduce of existing "legacy" options for creating interactive applications. And later in this chapter, we're going to introduce parts of upcoming HTML5 spec: Server-Sent Events and WebSockets.

We're going to implements fund-raising event monitoring functionality and interactive auction for Save Sick Child application using Websockets and  Server-Sent Events.
Using the monitoring tool we'll show the performance bandwidth usage benefits that WebSockets protocol brings to the Web.

Will use http://java.net/projects/tyrus[Project «Tyrus»] with http://dlc.sun.com.edgesuite.net/glassfish/4.0/promoted/[latest Glassfish builds] for server side Websocket implementation.

Show the server-side data push with Server-Sent Events and Websockets. Compare each other.
Look at http://socket.io/[Socket.IO] library. Compare the data throughput with the HTTP datapush demonstrated in Ch4.

=== Legacy Web and its options for «Realtime» apps

Being a web developers we use HTTP protocol as transport in our applications. At this point, out client-server communication is based on request-response paradigm. And underneath each and every http request-response session there is actual TCP/IP connection. And every time when we need to send data to server and get response back we have to we need accomplish this repetitive task. So to implement interactiveness in your application
Currently, there are 3 basic options (or its variants and combinations) what developer has to use today to satisfy real-time client-server communication requirements. Basically, that options provide hacks on top of half-duplex HTTP protocol to simulate real-time behaviour. Lets discuss each of them.

==== Polling aka Short Polling ====

With polling, your client code sends request to the server every X seconds The response is «empty» if there is no update. Refer to Figure 8-1
Good illustration of this approach is you child seating on back seat of your car and asking "Are we where?" every minute. And you replying back  with empty response "No, we're not". There is no actual interesting payload for your kid but he still receiving some "metadata". Same with short polling what uses HTTP response with verbose headers to send empty payload.

_TBD short polling illustration_

Figure 8-1 Short polling

==== Long Polling ====

Long polling is similar to short polling: client sends request to server and instead of sending empty response (as in case with short polling), server not committing the response until information is available. When information gets available or after certain timeout server sends response and closes connection. And this process is repeated. On the contrary of short polling, long polling response is never empty.
From HTTP specification perspective this "hack" is legit: long polling server behaviour indistinguishable from «slow» server.  That is why this technique also referred as "Hanging GET". Essentially, long polling is not server-push, but good emulation of it in situations where server push not available.

_TBD long polling illustration_

Figure 8-2 Long polling

==== HTTP Streaming ====

Response to client never
Client sends the request, server wait for events and  streams +multipart/chunked+ response, and then wait for the events. The response is continually appended by server, usually with `<script>` what gets executed even after page DOM is ready.

_TBD long polling illustration_

Figure 8-3 HTTP streaming

Describe above options could be used as fall-back transports for legacy browsers what doesn't support modern HTML5 APIs - _Server-Sent Events_ and _Websockets_.
Lets see how major browsers developers, W3C and community trying to standardize these hacks for modern web.

=== Server-Sent Events ===

Before we dive into Websocket lets briefly talk about standardised way to implement of server-side push client - Server-Sent Events. W3C introduces new browsers API and - http://dev.w3.org/html5/eventsource/[+eventSource+] object. SSE allow to subscribe to remote server events in form of DOM events. Lets check how browser code looks like.

[source,javascript]
-----------------------------------------------------
include::include/sse_api_example.js[]
-----------------------------------------------------

<1> Create new EventSource. At this point browser will sends GET request to specified endpoint to register itself on the server
<2> Add handlers for open and error
<3> Handle messages +create+ events
<4> Handle messages +update+ events

Server-Sent Events is good candidate when data doesn't need to be sent from the client to the server.
In this example server sends 2 types of events +create+ and +update+ to notify subscribed clients about changing information about donation data so connected clients can monitor fundraising process. We can create as many named-events as we want.
This technique still HTTP based but requires server support. In the server side combination of HTTP 1.1 Keep-alive connection and `text/event-stream` content type. Overhead minimal - instead of hundreds of bytes, server sends only tens of bytes.

=== Introducing Websockets

==== What is websockets? ====

Websockets is bi-direction full-duplex framed socket-based protocol.

Idea behind Websocket is very simple:
- establish socket connection connection between client and server using HTTP for initial handshake
- switch communication protocol from HTTP to socket-based connection
- send message to both directions
- send messages independently. No request-response model. Both server and client can initiate data transmission which enables real server-push
- as a consequence previous statement, each of stakeholders can initiate  disconnect.
We will talk of each of this statements later when we introduce Websocket API

====  IETF RFC 6455 Protocol ====

Websocket introduces new protocol URI - `ws` and `wss` for secured web-socket connection.

==== Websocket Interface ====

To define abstract Websocket interface expert group uses http://en.wikipedia.org/wiki/Interface_description_language[Interface Description Language]

[source,java]
----------------------------------------------------------------------
include::include/ws_interface.il[]
----------------------------------------------------------------------

<1> constructor is expecting mandatory endpoint URI and optional subprotocols name

===== Client-side API =====

Now, when we have basic idea of Websocket interface lets see how client side JavaScript API looks like.

[source,javascript]
----------------------------------------------------------------------
include::include/ws_api_example.js[]
----------------------------------------------------------------------

<1> Check if Websocket object is available in browser
<2> Instantiate new Websocket object with passing endpoint URI as constructor parameter
<3> Set event handlers for `open`, `message`, `clos` events
<4> `e.data` property of message event contains received from string message
<5> handle closing connection ...
<6> ... and errors

Websocket handshake
    1. client sends +GET+-request for protocol upgradein
    2. server send response and confirms protocol upgrade
    3. +websocket.readyState==1+
    4. +websocket.onmessage+ listener for incoming messages, +websocket.send()+ to send data to server

****

NOTE: There is no limit to the number of established WebSocket connections a client can have with a single remote host.  Servers can refuse to accept connections from hosts/IP addresses with an excessive number of existing connections or disconnect resource- hogging connections when suffering high load.

****

- websocket frame anatomy
- heartbeating
- Client-side frameworks
- Server-side API

=== Websocket Use Cases

WebSockets really shine with following applications:

- Live trading/sports ticker
- Controlling medical equipment over the web
- Chat applications
- Multiplayer online games
- Realtime updating social streams

For "Save Sick Child" application we're going to use Websockets to implement web-auction functionality. Using this web-auction contributors such individuals, businesses, charitable foundations can buy handmade crafts and arts made by children.

==== Protocols thoughts (for Enterprise world)

Downside: Websocket spec gives you only transport, but there is no high level protocol. Developers need to invent problem related protocols (text or binary).Lets discuss what are current options do we have from protocol modelling perspective.

- SOAP, XML, XSD
- REST, JSON, CSV
- http://code.google.com/p/protobuf-js/[ProtoBuff for js], [Apache Thrift]

=== Websockets and proxies

TBD

=== WebSockets and HTTP 2.0

[quote, Chief Product Architect at Akamai, Stephen Ludin]
____
"I use the metaphor of hammers and screwdrivers. Both tools are indispensable in my workshop...

Use the right tool for the job.
In the case of page and object delivery use SPDY.
In the case of lightweight or streaming data delivery look to WebSocket."

source: https://blogs.akamai.com/2012/07/spdy-and-websocket-support-at-akamai.html
____

- http 2.0, spdy, websockets
- framed protocols (describe frames)
