== Chapter 8. Replacing HTTP with WebSockets




[quote, http://ietf.org/mail-archive/web/hybi/current/msg00784.html ]
____
Shaving off hundreds of bytes of HTTP overhead and reducing the latency from 150ms to 50 ms makes WebSocket worthwhile considering for any application.
____

This chapter starts with introducing of existing "legacy" options for creating interactive Web applications. After that we're going to introduce Server-Sent Events (SSE) and WebSockets, which are included in HTML5 specification.

We're going to implement monitoring of the fund-raising events and an interactive auction for our Save Sick Child application using WebSockets and  Server-Sent Events. We'll use Wireshark, a network monitoring tool, to see benefits of using WebSockets protocol.

All server-side functionality supporting this chapter is written in Java, using the http://java.net/projects/tyrus[Project «Tyrus»] with http://dlc.sun.com.edgesuite.net/glassfish/4.0/promoted/[latest Glassfish builds]. If you don't know Java, just treat this server side setup as a service that supports WebSockets. For Java developers interested in diving into the server-side, we'll provide the source code and brief comments as a part of the code samples that come with this book.

TODO: Show the server-side data push with Server-Sent Events and WebSockets. Compare them.
Do a brief overview of the http://socket.io/[Socket.IO] library. Comparing sending data using WebSockets data throughput with the HTTP data push will be demonstrated in Chapter 4.

=== Near Realtime Applications With HTTP

The HTTP protocol is the lingua franca of today's Web  applications, where client-server communications are based on the request-response paradigm. On the low level, Web browsers establish a TCP/IP connection for each HTTP request-response session.  Every time when the browser needs to send data to server and get response back the browser re-establish the TCP/IP connection. So to implement interactiveness in your application currently, there are 3 basic options that developer has to use today to satisfy the real-time client-server communication requirements. Basically, that options provide hacks on top of half-duplex HTTP protocol to simulate real-time behavior. Lets discuss each of them.

==== Short Polling ====

With _short polling_, your client code sends requests to the server every N seconds. The response is «empty» if there is no update as illustrated in Figure 8-1. Visualize a child seating on back seat of your car and asking, "Are we where?" every minute. And you're politely replying "Not just yet" - compare it to a empty server response. There is no valuable payload for this kid, but she's still receiving some "metadata". HTTP polling does the same thing that generates verbose HTTP response headers sending empty payload. Let alone destructing the driver (think the server) from performing other responsibilities.

image:fig_08_01.png[image]

Figure 8-1 Short polling

==== Long Polling ====

_Long polling_ starts similarly to short polling: the client sends HTTP request to server. But in this case instead of sending an empty response (as in case with short polling), server waits till the data for the client becomes available. If the requested information is not available after the specified timeout, the server server sends an empty response to the client and closes the connection.

We'll give you one more analogy to compare short and long polling. Imagine a party at the top floor of a building equipped with a smart elevator that goes up every minute and opens the door just in case if one of the guests wants to go down to smoke a cigarette. If no one enters the elevator, it goes to the ground level and in 60 seconds goes up again. This is the short polling scenario. But if this elevator would go up, and waited till someone would actually decided to go down, then we could call it a long polling mode.

From HTTP specification perspective this "hack" is legit: long polling server behavior indistinguishable from «slow» server.  That is why this technique also referred as "Hanging GET". If you see an online auction that automatically modifies the prices as people bid on the item it looks as if the server pushes the data to you. But most likely, this functionality was implemented using long polling, which is not a real server-side data push, but its emulation.

image:fig_08_02.png[image]

Figure 8-2 Long polling

TODO Compare pros and cons of long vs short polling

==== HTTP Streaming ====

Client sends the request, server wait for events and  streams +multipart/chunked+ response, and then waits for the events. The server pushes the data to the client pretending that the response never ends. The response is continually appended by the server, usually with `<script>` what gets executed even after the HTTP DOM object is ready

image:fig_08_03.png[image]

Figure 8-3 HTTP streaming

Polling and streaming can be used as a fall-back for legacy browsers that don't support the modern HTML5 APIs _Server-Sent Events_ and _WebSockets_.

=== Server-Sent Events ===

Before diving into WebSockets protocol lets get familiar with the standardized way of implementing  Server-Sent Events. W3C introduces new browsers API and - http://dev.w3.org/html5/eventsource/[+EventSource+] object. SSE allows to subscribe to remote server events arriving in the form of DOM events. The following code snippet shows the JavaScript code that can be used in a Web browser.

[source,javascript]
-----------------------------------------------------
include::include/sse_api_example.js[]
-----------------------------------------------------

<1> Create new +EventSource+ object. At this point the browser will sends the +GET+ request to the specified server-side endpoint to register itself on the server
<2> Add handlers for the +open+ and +error+ events
<3> Handle messages in +create+ events
<4> Handle messages in +update+ events

Using SSE is a good technique for the use cases when the client doesn't need to send the data to the server. In the above example the server sends two types of events +create+ and +update+ to notify subscribed clients about changing information about donation data so connected clients can monitor fund-raising process. We can create as many named-events as we want.
This technique is still HTTP-based, and it requires the server's support of a combination of HTTP 1.1 keep-alive connections and the `text/event-stream` content type. The overhead is minimal - instead of hundreds of bytes, the server sends only tens of bytes.

=== Introducing WebSockets

WebSockets is a bi-directional full-duplex socket-based protocol. The idea behind WebSockets is straightforward:

- Establish a socket connection between the client and the server using HTTP for the initial handshake.
- Switch the communication protocol from HTTP to direct socket-based protocol
- Send messages in both directions simultaneously (full duplex).
- Send messages independently. No request-response model. Both the server and the client can initiate data transmission which enables real server-push
- Accordungly, both the server and the client can initiate  disconnect.

We will explain each of this statements later in this chapter while introducing WebSocket API.

====  IETF RFC 6455 Protocol ====

WebSocket introduces the new protocol URI's: `ws` and `wss` for secured web-socket connection.



==== WebSockets Interface ====

To define an abstract Web socket interface the expert group uses http://en.wikipedia.org/wiki/Interface_description_language[Interface Description Language]

[source,java]
----------------------------------------------------------------------
include::include/ws_interface.il[]
----------------------------------------------------------------------

<1> The constructor requires an endpoint URI and optional sub-protocols name.

===== Client-Side API =====

After the introduction of the WebSockets interface lets see how the client's JavaScript can use it.

[source,javascript]
----------------------------------------------------------------------
include::include/ws_api_example.js[]
----------------------------------------------------------------------

<1> Check if the +WebSocket+ object is supported by the browser.
<2> Instantiate the new +WebSocket+ object with passing endpoint URI as constructor parameter.
<3> Set event handlers for `open`, `message`, `close` events.
<4> `e.data` property of the message event contains the received message.
<5> handle closing connection ...
<6> ... and errors

===== WebSockets Handshake

Handshake upgrades connection from HTTP to Websockets. It's not an upgrade to TCP, it's an upgrade to a message based communication. We will discuss messages aka frames later.
Why you would need to upgrade from HTTP instead of directly starting with TCP as a protocol?
WebSockets uses the same ports as HTTP and HTTPS. It's an advantage because these are privileged ports (< 1024) and they are traditionally handled differently than non privileged ports. For instance, on a linux systems only root can open such ports. WebSockets use the same port as HTTP/HTTPS and it make this much more interesting. If anyone has ever used the flash socket policy system will know that FlashPlayer's VM will attempt to connect to port 843 to get authorization information.
We have to tunnel our communication through a HTTP because arbitrary socket connections are not possible for security or scalability reasons. In most of the cases, HTTP connections are possible where regular socket connections are not. Also many corporate networks only allow certain ports outgoing. And HTTP/HTTPS ports are usually included in white list.
The upgrade is initiated by the client, not by the server.
They also transmit a special key with the upgrade request which the server has to process and send back. This is done so that a WebSocket connection cannot be established with an endpoint that is not aware of WebSockets.
Here is what the handshake looks like for the client:

----------------------------------------------------------------------

    GET HTTP/1.1
    Upgrade: websocket
    Connection: Upgrade
    Host: echo.websocket.org
    Origin: http://www.websocket.org
    Sec-WebSocket-Key: i9ri+AfOgSsKwUlmLjIkGA==
    Sec-WebSocket-Version: 13

----------------------------------------------------------------------

Here the client sends +GET+ request for the protocol upgrade.
The websocket key here are random bytes. The server takes these bytes and appends the special GUID string `258EAFA5-E914-47DA-95CA-C5AB0DC85B11` to it, then creates the +SHA1+ hash from it and base64 encodes the resulting bytes. The exact string needs to be used in server and client and this string unlikely to be used by network endpoints that do not understand the WebSocket. This value would then be echoed in the `Sec-WebSocket-Accept` header field. When the server has computed the value it can send an upgrade response back confirming the protocol upgrade.

----------------------------------------------------------------------

    HTTP/1.1 101 Web Socket Protocol Handshake
    Upgrade: WebSocket
    Connection: Upgrade
    Sec-WebSocket-Accept: Qz9Mp4/YtIjPccdpbvFEm17G8bs=
    Access-Control-Allow-Origin: http://www.websocket.org

----------------------------------------------------------------------

WebSockets are using `400 Bad Request` to signal a missing upgrade.
The handshake can also include a protocol request and the websocket version information but you can't include arbitrary other headers. We can't transmit the authorization information. There are two ways around that. You can either transmit the authorization information as the first request or put it into the URL as query parameter.

****

NOTE: There is no limit to the number of established WebSocket connections a client can have with a single remote host.  Servers can refuse to accept connections from hosts/IP addresses with an excessive number of existing connections or disconnect resource-hogging connections in case of high data load.

****

===== The WebSocket frame anatomy =====


----------------------------------------------------------------------

+-+-+-+-+-------+-+-------------+-------------------------------+
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               | Masking-key, if MASK set to 1 |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+

----------------------------------------------------------------------

===== The Heartbeats =====

Certain things (like proxies) can terminate idle connections or remote side could go down. Only at the next send would you realize that something went wrong.
With WebSockets browser can send the ping opcode `0x9` at any time to ask the other side to pong (opcode `0xA`).
Pings can be sent whenever an endpoint thinks it should and a pong is sent based on server discretion. If an endpoint receives a Ping frame and has not yet sent Pong frame(s) in response to previous Ping frame(s), the endpoint can elect to send a Pong frame for only the most recently processed Ping frame.
Ping frame may contain application data (can be up to 125 bytes) and Pong must have identical data in message body.
There is no Javascript API to send ping frames or receive pong http://www.whatwg.org/specs/web-apps/current-work/multipage/network.html#ping-and-pong-frames[frames]. This is either supported by your browser, or not. http://www.w3.org/Bugs/Public/show_bug.cgi?id=13104[There is also no API] to enable, configure or detect whether the browser supports and is using ping/pong frames.

_TODO_
- Client-side frameworks
- Server-side API

=== WebSocket Use Cases

WebSockets really shine with following applications:

- Live trading/auctions/sports notifications
- Controlling medical equipment over the web
- Chat applications
- Multi-player online games
- Real-time updates in social streams

For the "Save Sick Child" application we're going to use WebSockets to implement an online auction communication layer. The goal is to let individuals and businesses purchase hand-made crafts and arts made by the children. All proceeds will go to help sick children.

==== Protocols Considerations for Enterprise Applications

The downside: WebSockets specification gives you only the transport, but it doesn't include the application-level protocol. Developers need to invent the application-specific text or binary protocols. For example, the auction bid has to be presented in a form agreed upon by all application modules. Let's discuss our options from protocol modeling perspective.

- SOAP, XML, XSD
- REST, JSON, CSV
- http://code.google.com/p/protobuf-js/[ProtoBuff for js], http://thrift.apache.org/[Apache Thrift]

_TODO_

=== WebSockets and Proxies

HTTP always supported upgrades, but unfortunately many proxies seem to have ignored that part of the specification. The main reason for that probably is that until WebSockets came around no one was actually using the Upgrade flag.

=== WebSockets and HTTP 2.0

[quote, Chief Product Architect at Akamai, Stephen Ludin]
____
"I use the metaphor of hammers and screwdrivers. Both tools are indispensable in my workshop...

Use the right tool for the job.
In the case of page and object delivery use SPDY.
In the case of lightweight or streaming data delivery look to WebSocket."

source: https://blogs.akamai.com/2012/07/spdy-and-websocket-support-at-akamai.html
____

- http 2.0, spdy, websockets
- framed protocols (describe frames)
